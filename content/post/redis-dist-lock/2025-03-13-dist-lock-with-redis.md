+++
date = '2025-03-13T23:00:25+09:00'
draft = false
title = 'Redis ê¸°ë°˜ì˜ ë¶„ì‚° ë½, ê·¸ë¦¬ê³  Redlock ì•Œê³ ë¦¬ì¦˜'
lastmodified = "2025-03-13T23:00:25+09:00"
author = "Chaewon Kong"
summary = 'ë¶„ì‚° ë½ì— ëŒ€í•´ ì•Œì•„ë³¸ë‹¤. Redisë¥¼ ì´ìš©í•œ ê°„ë‹¨í•œ ë¶„ì‚° ë½ì„ êµ¬í˜„í•´ ë³¸ë‹¤. Redlock ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ì„œë„ ì•Œì•„ë³¸ë‹¤. Goë¡œ Redlock ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ë„ ì •ë¦¬í•œë‹¤.'
keywords = ['Distributed System', 'Go', 'Redis', 'Redlock Algorithm']
+++

# Redis ê¸°ë°˜ì˜ ë¶„ì‚° ë½, ê·¸ë¦¬ê³  Redlock ì•Œê³ ë¦¬ì¦˜

ë¶„ì‚° ë½(Distributed Lock)ì€ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ë‚˜ ë…¸ë“œê°€ ê³µìœ  ë¦¬ì†ŒìŠ¤ì— ë™ì‹œì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë¶„ì‚° í™˜ê²½ì—ì„œ ë¦¬ì†ŒìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ ì œì–´í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ë½ ë§¤ì»¤ë‹ˆì¦˜ì´ë‹¤.

ì˜¤ëŠ˜ ì£¼ì œëŠ” ì•„ë˜ì™€ ê°™ì€ ë‹µì— ëŒ€í•œ ëŒ€ë‹µì„ ì°¾ê¸° ìœ„í•œ ê²ƒì´ë‹¤.

- ê³µì—°ì¥ í‹°ì¼“ ì˜ˆë§¤ë¥¼ í•  ë•Œ ì–´ë–»ê²Œ ê°™ì€ ì¢Œì„ì´ ë™ì‹œì— ì—¬ëŸ¬ ì‚¬ëŒì—ê²Œ íŒë§¤ë˜ëŠ” ê²ƒì„ ë§‰ì„ ìˆ˜ ìˆì„ê¹Œ?
- ì—¬ëŸ¬ ë…¸ë“œì—ì„œ cron jobì„ ì‹¤í–‰í•  ë•Œ í•œ ë²ˆë§Œ ì‹¤í–‰í•˜ê²Œ í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€?
- ê²°ì œ ê´€ë ¨ DBì™€ ìƒí’ˆ ì¬ê³  ê´€ë ¨ DBê°€ ë¶„ë¦¬ë˜ì–´ ìˆì„ ë•Œ, ì–´ë–»ê²Œ transaction ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìˆì„ê¹Œ?

## ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œë“¤

### ê²½ìŸ ì¡°ê±´(Race Condition) ë°œìƒ

- ì—¬ëŸ¬ ë…¸ë“œê°€ ë™ì‹œì— ê°™ì€ ìì›ì— ì ‘ê·¼í•´ ì‘ì—…í•˜ë©´ì„œ ì‘ì—… ìˆœì„œê°€ ê¼¬ì´ëŠ” ê²½ìš°
- ë‘ ì„œë²„ê°€ ë™ì‹œì— DBì—ì„œ ê°™ì€ ê°’ì„ ì½ê³  ìˆ˜ì •í•  ê²½ìš° ë‚˜ì¤‘ì— ìˆ˜ì •í•œ ê°’ë§Œ ë‚¨ëŠ” ê²½ìš° ë“±

### ì¤‘ë³µ ì‘ì—… ë°œìƒ

- ë™ì¼í•œ ì‘ì—…ì´ ì—¬ëŸ¬ ë…¸ë“œì—ì„œ ì¤‘ë³µ ì‹¤í–‰ë˜ëŠ” ê²½ìš°
- ì—¬ëŸ¬ ë…¸ë“œì—ì„œ ë³‘ë ¬ë¡œ ìˆ˜í–‰ë˜ëŠ” cron ì‘ì—…

### ë°ì´í„° ì¼ê´€ì„± ë¶•ê´´

- ë¶„ì‚° ì‹œìŠ¤í…œì˜ ê° ë…¸ë“œê°€ ì„œë¡œ ë‹¤ë¥¸ ì‹œì ì˜ ë°ì´í„°ë¥¼ READ í•˜ë©´ì„œ ë°ì´í„° ì¼ê´€ì„±ì´ ê¹¨ì§
- ê²°ì œ ì‹œìŠ¤í…œì— A, B ì„œë²„ê°€ ê²°ì œë¥¼ ë‹´ë‹¹í•œë‹¤ê³  ê°€ì •
    - ìƒí’ˆì˜ ì¬ê³ ê°€ 1ê°œë§Œ ë‚¨ì€ ìƒí™©
    - A ì„œë²„ê°€ ì¬ê³ ê°€ 1ê°œ ë‚¨ì€ ê²ƒì„ í™•ì¸í•¨ê³¼ ë™ì‹œì— B ì„œë²„ì—ì„œ ê²°ì œë¥¼ ì§„í–‰í•˜ë©° ì¬ê³ ë¥¼ 1 ê°ì†Œì‹œí‚¤ë©´, A ì„œë²„ì—ì„œ ê²°ì œë¥¼ ì§„í–‰í•˜ëŠ” ê³¼ì •ì—ì„œëŠ” ì‚¬ì‹¤ ì¬ê³ ê°€ 0ì¸ ë¬¸ì œ ë°œìƒ

### ë¦¬ë” ì„ ì¶œ ì´ìŠˆ

- ì—¬ëŸ¬ ë…¸ë“œ ì¤‘ì— ë”± 1ê°œì˜ ë…¸ë“œë§Œ ë¦¬ë”ë¡œ ì„ ì¶œë˜ì–´ì•¼ í•¨. ë™ì‹œì— ì—¬ëŸ¬ ë…¸ë“œê°€ ë¦¬ë”ë¡œ ì„ ì¶œë˜ì–´ì„œëŠ” ì•ˆë¨.
- ì¹´í”„ì¹´ì—ì„œ ë¸Œë¡œì»¤ ê°„ ì¡°ìœ¨ì„ ìœ„í•´ ë¦¬ë” ë¸Œë¡œì»¤ë¥¼ ì„ ì¶œí•˜ëŠ” ê²½ìš°

## Lockì˜ ëª©ì 

### Efficiency

ë™ì¼í•œ ì‘ì—…ì„ ì—¬ëŸ¬ ë…¸ë“œê°€ ë°˜ë³µí•¨ìœ¼ë¡œì¨ ë¶ˆí•„ìš”í•œ ë¹„ìš©ì´ ë°œìƒí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ Lockì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### Correctness

Concurrentí•œ í”„ë¡œì„¸ìŠ¤ë“¤ì´ ë™ì¼í•œ ìì›ì— ì ‘ê·¼í•˜ê³  ìˆ˜ì •í•˜ë ¤ í•˜ì—¬ ë°œìƒí•˜ëŠ” ì¼ê´€ì„± í›¼ì†, ì˜¤ì—¼ëœ ë°ì´í„° ë“±ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ Lockì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

Martin Kleppmann(Designing Data-intensive Applications ì €ì)ì— ë”°ë¥´ë©´ ë¶„ì‚° ë½ì„ ë„ì…í•  ë•ŒëŠ” Efficiencyì™€ Correctness ì¤‘ ì–´ë–¤ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„œ ë„ì…í•˜ëŠ”ì§€ ëª…í™•íˆ ì´í•´í•´ì•¼ í•œë‹¤ê³  í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, Efficiencyë¥¼ ìœ„í•œ ë¶„ì‚° ë½ ë„ì…ì´ë¼ë©´ Redlock Algorithmì€ ì í•©í•˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. ë™ì¼í•œ ì‘ì—…ì˜ ë°˜ë³µì„ ì¤„ì´ê¸° ìœ„í•´ ì„œë¡œ ë‹¤ë¥¸ 5ëŒ€ì˜ Redis masterë¥¼ ë‘ê³  ë‹¤ìˆ˜ì˜ masterì—ì„œ lock íšë“ì„ ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë” í´ ê°€ëŠ¥ì„±ì´ ë†’ê¸° ë•Œë¬¸ì´ë‹¤.

## Redisë¥¼ ì´ìš©í•œ ë¶„ì‚° ë½ êµ¬í˜„

RedisëŠ” ì‹±ê¸€ ìŠ¤ë ˆë“œ ê¸°ë°˜ì˜ ì¸ ë©”ëª¨ë¦¬ ì €ì¥ì†Œë¡œ ì½ê¸°ì™€ ì“°ê¸°ê°€ ë¹ ë¥´ê³ , ì‹±ê¸€ ìŠ¤ë ˆë“œì—ì„œ í•œ ë²ˆì— í•˜ë‚˜ì˜ ì»¤ë§¨ë“œì”© ìˆœì°¨ ì²˜ë¦¬ë˜ê¸° ë•Œë¬¸ì— ë½ êµ¬í˜„ì— ìì£¼ ì´ìš©ëœë‹¤.

### ë¶„ì‚° í™˜ê²½ì—ì„œ ë™ì‘í•˜ëŠ” cron ì‘ì—… ì˜ˆì‹œ

ì´ì¤‘í™”ëœ ì—¬ëŸ¬ ë…¸ë“œê°€ ì¡´ì¬í•˜ëŠ” í™˜ê²½ì—ì„œ cron ì‘ì—…ì€ íšŒë‹¹ 1ë²ˆë§Œ ë™ì‘í•˜ë„ë¡ í•˜ëŠ” ì˜ˆì‹œë¥¼ êµ¬í˜„í•´ ë³¸ë‹¤.

- ì—¬ëŸ¬ ê°œì˜ ë…¸ë“œì—ì„œ cron ì‘ì—…ì´ ì‹¤í–‰ë  ìˆ˜ ìˆë‹¤
- í•˜ë‚˜ì˜ ë…¸ë“œì—ì„œ ë¨¼ì € cron ì‘ì—…ì´ ì‹œì‘ë˜ë©´, ë‹¤ë¥¸ ë…¸ë“œì—ì„œëŠ” í•´ë‹¹ ì‘ì—…ì„ ì‹¤í–‰í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤

### cronìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ì‘ì—… ì •ì˜

10ì´ˆ ê°„ ì‘ì—…ì´ ìˆ˜í–‰ë˜ëŠ” ê²ƒì„ mockginí–ˆë‹¤.

```go
func runCronTask() {
	// ì‹¤ì œ ì‹¤í–‰í•  í¬ë¡  ì‘ì—… (ì—¬ê¸°ì„  10ì´ˆ ëŒ€ê¸°)
	fmt.Println("ì‘ì—… ì¤‘... â³")
	time.Sleep(10 * time.Second)
	fmt.Println("ì‘ì—… ì™„ë£Œ! ğŸ‰")
}
```

### ë©”ì¸ êµ¬ì¡°

lockì´ ê±¸ë ¤ ìˆìœ¼ë©´ ì‹¤í–‰í•˜ì§€ ì•Šìœ¼ë©°, lockì´ ê±¸ë ¤ ìˆì§€ ì•Šìœ¼ë©´ ì‘ì—…ì„ ì‹¤í–‰í•œë‹¤.

```go
func main() {
	ctx := context.Background()

	// Redis í´ë¼ì´ì–¸íŠ¸ ìƒì„±
	client := newRedisClient("localhost:6379", "", 0)

	// ë¶„ì‚° ë½ íšë“ ì‹œë„
	acquired, err := client.acquireLock(ctx, lockKey, lockTTL)
	if err != nil {
		log.Fatalf("Redis ì—°ê²° ì˜¤ë¥˜: %v", err)
	}

	if !acquired {
		fmt.Println("ë‹¤ë¥¸ ì„œë²„ì—ì„œ ì´ë¯¸ í¬ë¡  ì‘ì—… ì‹¤í–‰ ì¤‘! ğŸš«")
		return
	}

	fmt.Println("í¬ë¡  ì‘ì—… ì‹¤í–‰ ì‹œì‘... âœ…")

	// í¬ë¡  ì‘ì—… ì‹¤í–‰ (ì˜ˆ: ë°ì´í„° ë°±ì—…)
	runCronTask()

	// ë½ í•´ì œ
	client.releaseLock(ctx, lockKey)
	fmt.Println("í¬ë¡  ì‘ì—… ì™„ë£Œ, ë½ í•´ì œ ğŸ”“")
}
```

newRedisClientëŠ” acquireLockê³¼ releaseLock ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” redis clientë¥¼ ìƒì„±í•˜ëŠ” ìƒì„±ìë‹¤. ì•„ë˜ì—ì„œ êµ¬í˜„ ì½”ë“œëŠ” ë‹¤ì‹œ ì„¤ëª…í•œë‹¤.

### Lock êµ¬í˜„

```go
import "github.com/redis/go-redis/v9"

// ë½ ê´€ë ¨ ìƒìˆ˜
const lockKey = "cron:job:my-task"
const lockTTL = 30 * time.Second // ë½ ìœ ì§€ ì‹œê°„

// ë¶„ì‚° ë½ì— ì‚¬ìš©í•  redis client
type redisClient struct {
	client *redis.Client
}

func newRedisClient(addr, password string, db int) *redisClient {
	return &redisClient{
		client: redis.NewClient(&redis.Options{
			Addr:     addr,     // Redis ì£¼ì†Œ
			Password: password, // íŒ¨ìŠ¤ì›Œë“œ (ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´)
			DB:       db,       // ê¸°ë³¸ DB
		}),
	}
}

// acquireLock ë½ íšë“ ë©”ì„œë“œ
func (r *redisClient) acquireLock(ctx context.Context, key string, ttl time.Duration) (bool, error) {
	ok, err := r.client.SetNX(ctx, key, "locked", ttl).Result()
	if err != nil {
		return false, err
	}
	return ok, nil
}

// releaseLock ë½ í•´ì œ ë©”ì„œë“œ
func (r *redisClient) releaseLock(ctx context.Context, key string) {
	r.client.Del(ctx, key)
}
```

ë½ì˜ íšë“ê³¼ í•´ì œëŠ” go-redisì˜ SetNXë¥¼ ì´ìš©í–ˆë‹¤. 

ì°¸ê³ ë¡œ SetNX ëª…ë ¹ì–´ëŠ” deprecatedëœ ëª…ë ¹ì–´ì§€ë§Œ go-redisì—ì„œëŠ” SetNXë¥¼ ì§€ì›í•˜ê³  ìˆìœ¼ë©° ë‚´ë¶€ì ìœ¼ë¡œëŠ” Set ëª…ë ¹ì–´ë¥¼ ì´ìš©í•´ not exist ìƒí™©ì—ì„œ setì„ í•˜ê³  ìˆë‹¤.

Lock ì„¤ì •ì„ í•  ë•ŒëŠ” TTLì„ ë‘ì–´ ë°ë“œë½ì„ ë°©ì§€í•œë‹¤.

### ì£¼ì˜ì‚¬í•­ ë° ê³ ë ¤ì 

- **ë°ë“œë½ ë°©ì§€:** TTL(íƒ€ì„ì•„ì›ƒ)ì„ ì„¤ì •í•´ ë½ì´ ë¬´í•œì • ê±¸ë ¤ ìˆì§€ ì•Šë„ë¡ ê´€ë¦¬.
- **ë½ ì¬í™•ì¸:** ë½ì´ ë§Œë£Œë˜ì—ˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ, ì‘ì—… ì¤‘ê°„ì— ë½ ìƒíƒœë¥¼ ì¬í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€.
- **ë½ ì´ì¤‘ í™•ì¸:** Redlock ê°™ì€ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ ë¶„ì‚° í™˜ê²½ì—ì„œ ë½ì˜ ì•ˆì •ì„±ì„ ê°•í™”.

ì§€ê¸ˆê¹Œì§€ëŠ” Redisê°€ ì‹±ê¸€ ì¸ìŠ¤í„´ìŠ¤ì¸ ìƒí™©ì„ ê³ ë ¤í•´ì„œ Lock êµ¬í˜„ì„ í–ˆë‹¤. í•˜ì§€ë§Œ, ì´ êµ¬í˜„ì—ëŠ” í•œ ê°€ì§€ í° ë¬¸ì œê°€ ì¡´ì¬í•œë‹¤.

**Redisê°€ SPoF(Single Point of Failure)ê°€ ëœë‹¤ëŠ” ì ì´ë‹¤.**

ê·¸ë ‡ë‹¤ë©´ ì‹±ê¸€ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë‹ˆë¼ master-slave êµ¬ì¡°ë©´ ë˜ëŠ” ê²ƒ ì•„ë‹Œê°€? ë‹µì€ ê·¸ë ‡ê²Œ ê°„ë‹¨í•˜ì§€ ì•Šë‹¤.

## RedLock ì•Œê³ ë¦¬ì¦˜

### Master Slave êµ¬ì¡°ì˜ í—›ì 

1. Client Aê°€ masterë¡œë¶€í„° lockì„ íšë“
2. masterê°€ replicaì— lock ì •ë³´ë¥¼ ì „ë‹¬í•˜ê¸° ì „ì— crash ë°œìƒìœ¼ë¡œ down
3. replicaëŠ” masterë¡œ ìŠ¹ê²©ë¨
4. Client BëŠ” replicaì˜€ë˜ masterë¡œë¶€í„° lockì„ íšë“. ê·¸ëŸ¬ë‚˜ ì´ ë¦¬ì†ŒìŠ¤ëŠ” Aê°€ ì•„ì§ ì‘ì—…í•˜ê³  ìˆëŠ” ë¦¬ì†ŒìŠ¤ì„.

### RedLock ì•Œê³ ë¦¬ì¦˜

Redlock ì•Œê³ ë¦¬ì¦˜ì€ **ì—¬ëŸ¬ ê°œì˜ Redis ë…¸ë“œ**ì—ì„œ ë½ì„ íšë“í•˜ì—¬, í•˜ë‚˜ì˜ Redis ì¸ìŠ¤í„´ìŠ¤ê°€ ì¥ì• ë¥¼ ê²ªë”ë¼ë„ **ì „ì²´ ì‹œìŠ¤í…œì˜ ì¼ê´€ì„±**ê³¼ **ì‹ ë¢°ì„±**ì„ ìœ ì§€í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.

1. **ì—¬ëŸ¬ Redis ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©**: Redlockì€ ì—¬ëŸ¬ Redis ì„œë²„ì— ë½ì„ ìš”ì²­í•˜ì—¬, ì‹œìŠ¤í…œì´ **í•˜ë‚˜ì˜ Redis ë…¸ë“œ ì¥ì• **ì— ì˜í–¥ì„ ë°›ì§€ ì•Šë„ë¡ í•¨. ì´ë¥¼ ìœ„í•´ ìµœì†Œ **5ê°œì˜ Redis ë…¸ë“œ**ê°€ í•„ìš”.
2. **ë½ì„ íšë“í•˜ë ¤ë©´ ê³¼ë°˜ìˆ˜ ì´ìƒ**ì˜ Redis ì„œë²„ì—ì„œ ë½ì„ íšë“í•´ì•¼ í•¨. ì˜ˆë¥¼ ë“¤ì–´, **5ê°œì˜ Redis ì„œë²„**ê°€ ìˆì„ ë•Œ **3ê°œ ì´ìƒì˜ ì„œë²„ì—ì„œ ë½ì„ íšë“**í•´ì•¼ í•´ë‹¹ ë½ì„ ìœ íš¨í•˜ë‹¤ê³  íŒë‹¨.
3. **ë½ì˜ ìœ íš¨ì„± ê²€ì¦**: ê° Redis ì„œë²„ì—ì„œ ë½ì„ íšë“í•˜ëŠ”ë° ì†Œìš”ë˜ëŠ” ì‹œê°„ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë½ì„ íšë“í•œ í›„ì˜ **ë§Œë£Œ ì‹œê°„ì„ ê²€ì¦**í•˜ì—¬ ë½ì´ ìœ íš¨í•œì§€ í™•ì¸.

### **Redlock ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ê³¼ì •**

í´ë¼ì´ì–¸íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ ë™ì‘í•œë‹¤.

1. í˜„ì¬ ì‹œê°„ì„ ë°€ë¦¬ì´ˆë¡œ ê¸°ë¡
2. ë™ì¼í•œ í‚¤ì™€ ëœë¤ ê°’ìœ¼ë¡œ ëª¨ë“  Nê°œì˜ Redis ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆœì°¨ì ìœ¼ë¡œ ë½ì„ ì‹œë„. ê° ì‹œë„ì—ëŠ” ì§§ì€ íƒ€ì„ì•„ì›ƒì„ ì„¤ì •í•´, ë…¸ë“œê°€ ë‹¤ìš´ë˜ë©´ ë°”ë¡œ ë‹¤ìŒ ì¸ìŠ¤í„´ìŠ¤ ì´ë™.
3. ë½ì„ íšë“í•˜ëŠ” ë° ê±¸ë¦° ì‹œê°„ì„ ê³„ì‚°í•˜ê³ , Nê°œì˜ ì¸ìŠ¤í„´ìŠ¤ ì¤‘ ê³¼ë°˜ìˆ˜ ì´ìƒì—ì„œ ë½ì„ íšë“í•˜ê³ , ê±¸ë¦° ì‹œê°„ì´ ë½ì˜ ìœ íš¨ ì‹œê°„ë³´ë‹¤ ì§§ìœ¼ë©´ ë½ì„ íšë“í–ˆë‹¤ê³  íŒë‹¨.
4. ë½ì„ íšë“í•˜ë©´, ìœ íš¨ ì‹œê°„ì€ ì´ˆê¸° ìœ íš¨ ì‹œê°„ì—ì„œ ê±¸ë¦° ì‹œê°„ì„ ëº€ ê°’ìœ¼ë¡œ ì„¤ì •.
5. ë½ì„ íšë“í•˜ì§€ ëª»í•œ ê²½ìš°, í˜¹ì€ ë½ì˜ ìœ íš¨ì‹œê°„ì´ ë§ˆì´ë„ˆìŠ¤ì¸ ê²½ìš°(íšë“ ê³¼ì •ì—ì„œ ì´ˆê³¼ë¨), ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ë½ì„ í•´ì œ.

### **ì¥ì **

- **ë†’ì€ ê°€ìš©ì„±**: ì—¬ëŸ¬ Redis ì„œë²„ë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— í•˜ë‚˜ì˜ ì„œë²„ê°€ ë‹¤ìš´ë˜ë”ë¼ë„ ë½ì´ ê³„ì†í•´ì„œ ìœ ì§€.
- **ë†’ì€ ì‹ ë¢°ì„±**: ì—¬ëŸ¬ ì„œë²„ì—ì„œ ë½ì„ íšë“í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œì˜ ì‹ ë¢°ì„±ì„ ë³´ì¥.
- **ê³ ê¸‰ ë¶„ì‚° ë½**: Redlockì€ **ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ ì•ˆì „í•œ ë½ì„ ì œê³µ**í•˜ë©°, **ìƒí˜¸ ë°°íƒ€ì **ì¸ ì‘ì—…ì„ ë³´ì¥.

### **ë‹¨ì **

- **ë³µì¡ì„±**: ì—¬ëŸ¬ Redis ì„œë²„ì™€ í†µì‹ í•´ì•¼ í•˜ë¯€ë¡œ êµ¬í˜„ì´ ë‹¤ì†Œ ë³µì¡.
- **ì„±ëŠ¥ ì €í•˜**: ê° ì„œë²„ì™€ í†µì‹ í•˜ëŠ” ë° ì‹œê°„ì´ ì†Œìš”ë˜ë¯€ë¡œ **ì„±ëŠ¥ ì €í•˜**. ë½ íšë“ì— ì‹¤íŒ¨í•  ê²½ìš° ì¬ì‹œë„ ë¡œì§ì„ êµ¬í˜„í•´ì•¼ í•˜ë¯€ë¡œ, ëŒ€ê·œëª¨ ë¶„ì‚° í™˜ê²½ì—ì„œëŠ” ì„±ëŠ¥ì— ì˜í–¥.
- **Redis ë…¸ë“œ ê°„ì˜ ì‹œê°„ ë™ê¸°í™” í•„ìš”**: Redlockì€ ì—¬ëŸ¬ ì„œë²„ì—ì„œ ë½ì„ íšë“í•˜ê³  ë§Œë£Œ ì‹œê°„ì„ ê³„ì‚°í•˜ë¯€ë¡œ, **ê° ì„œë²„ì˜ ì‹œê°„**ì´ ì •í™•íˆ ë™ê¸°í™”ë˜ì–´ì•¼ í•¨.

### ê³ ë ¤ì‚¬í•­

- ê° Redis masterëŠ” ë…ë¦½ëœ ì»´í“¨í„°ë‚˜ VMì—ì„œ ì‹¤í–‰ë˜ì–´ ì„œë¡œ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•œë‹¤.
- split brain conditionì„ ìµœì†Œí™” í•˜ê¸° ìœ„í•´ì„œ ì´ë¡ ì ìœ¼ë¡œëŠ” clientëŠ” multiplexingì„ ì´ìš©í•´ì„œ Nê°œì˜ masterì— ë™ì‹œì— SET commandë¥¼ ì „ì†¡í•´ ë‹¤ìˆ˜ì˜ masterì—ì„œ ìµœëŒ€í•œ ë¹ ë¥´ê²Œ, ë™ì‹œì— lockì„ íšë“í•´ì•¼ í•œë‹¤.
- ë‹¤ìˆ˜ì˜ masterì—ì„œ lock íšë“ì— ì‹¤íŒ¨í•œ í´ë¼ì´ì–¸íŠ¸ëŠ” key ë§Œë£Œë¥¼ ê¸°ë‹¤ë¦¬ì§€ ë§ê³  ì¦‰ì‹œ íšë“í•œ lockì„ releaseí•´ì•¼ í•œë‹¤.

### í•œê³„

> ì•„ë˜ ë‚´ìš©ì€ Martin Kleppmannì˜ ë¸”ë¡œê·¸ì— ì •ë¦¬ëœ Redlock ì•Œê³ ë¦¬ì¦˜ì˜ í•œê³„ë¥¼ ì •ë¦¬í•œ ê²ƒì´ë‹¤.
[https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
> 

ë¶„ì‚° ë½ ìì²´ëŠ” ì•„ë˜ì™€ ê°™ì€ ì ì¬ì  crash ìš”ì†Œë¥¼ ê°€ì§€ê³  ìˆë‹¤.

![Martin Kleppmann, *How to do distributed locking*](https://martin.kleppmann.com/2016/02/unsafe-lock.png)

Martin Kleppmann, *How to do distributed locking*

- client 1ì´ lock íšë“ì— ì„±ê³µí•˜ê³  storage writeë¥¼ ì‹œë„í•˜ëŠ” ë„ì¤‘ ì§€ì—°ì´ ë°œìƒ (GC, ë„¤íŠ¸ì›Œí¬ ì§€ì—° ë“±)
- ê·¸ ì‚¬ì´ lockì´ expireë¨
- client2ê°€ lockì„ íšë“í•˜ê³  client1ì˜ ì‘ì—…ì´ ì¢…ë£Œë˜ê¸° ì „ì— storageì— writeë¥¼ ì™„ë£Œ
- client1ì´ storageì— writeë¥¼ ì™„ë£Œ (data corruption!)

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ fencing tokenì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. fencing tokenì€ ì ì§„ì ìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ìˆ«ìë¡œ ëœ í† í°ì¸ë°, ë§Œì•½ storageì— writeìš”ì²­ì´ ë“¤ì–´ì™”ì„ ë•Œ í•´ë‹¹ fencing tokenì˜ ìˆ«ìê°€ ì§ì „ì— writeì— ì„±ê³µí•œ fencing tokenì˜ ìˆ«ìë³´ë‹¤ ë” ë‚®ë‹¤ë©´ old tokenìœ¼ë¡œ ê°„ì£¼í•´ write ì‘ì—…ì„ ê±°ë¶€í•˜ëŠ” ê²ƒì´ë‹¤.

ë¬¸ì œëŠ” Redlock Algorithmì´ë‚˜ Redisê°€ ë‚´ë¶€ì ìœ¼ë¡œ ì´ëŸ° ë§¤ì»¤ë‹ˆì¦˜ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì´ë©°, ì„¤ì‚¬ ì–µì§€ë¡œ ì œê³µí•˜ë”ë¼ë„ ì„œë¡œ ë‹¤ë¥¸ nê°œì˜ ë§ˆìŠ¤í„°ê°€ ì™„ì „íˆ ë™ê¸°í™”ëœ fencing tokenì„ ì œê³µí•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤ëŠ” ë¬¸ì œê°€ ë°œìƒí•œë‹¤.

**Timing ê´€ë ¨ ì´ìŠˆ**

ê° ë…¸ë“œê°€ ìƒê°í•˜ëŠ” ì‹œê°„ì€ ì •í™•íˆ ë™ê¸°í™”ë˜ì§€ ì•Šìœ¼ë©°, ì—¬ëŸ¬ ì´ìœ ì—ì„œ ëª‡ ë¶„ê¹Œì§€ë„ ì°¨ì´ê°€ ë‚  ìˆ˜ ìˆë‹¤.

ì´ëŸ° ì´ìœ ì—ì„œ ë¶„ì‚° í™˜ê²½ì—ì„œ íƒ€ì´ë° ì´ìŠˆëŠ” ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ”ë°, íŠ¹íˆ Redlock ì•Œê³ ë¦¬ì¦˜ì€ timingì— í¬ê²Œ ì˜ì¡´í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ì ì¬ì ìœ¼ë¡œ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

> However, Redlock is not like this. Its safety depends on a lot of timing assumptions: it assumes that all Redis nodes hold keys for approximately the right length of time before expiring; that the network delay is small compared to the expiry duration; and that process pauses are much shorter than the expiry duration.
> 

ì´ëŸ° ì´ìœ ë¡œ ì¸í•´ Martin Kleppmannì€ Redlock Algorithmì´ ê°„ë‹¨í•˜ì§€ë„ ì•Šê³  ì •í™•í•¨ì„ ë³´ì¥í•˜ì§€ë„ ì•Šê¸°ì— ë¶„ì‚° ì‹œìŠ¤í…œì˜ Locking ë§¤ì»¤ë‹ˆì¦˜ìœ¼ë¡œëŠ” ì í•©í•˜ì§€ ì•Šë‹¤ê³  ì£¼ì¥í•œë‹¤.

## Goë¡œ Redlock ì‰½ê²Œ ì“°ê¸°

Redsync ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•˜ë©´ ì‰½ê²Œ Redlock Algorithmì„ ì ìš©í•  ìˆ˜ ìˆë‹¤.

```go
func main() {
	// redis connection poolì„ ìƒì„±
	redisAddrs := []string{
		"localhost:6379",
		"localhost:16379",
		"localhost:26379",
		"localhost:36379",
		"localhost:46379",
	}
	var pools []redsyncredis.Pool
	for _, addr := range redisAddrs {
		client := redis.NewClient(&redis.Options{
			Addr: addr,
		})
		pools = append(pools, goredis.NewPool(client))
	}

	// redis connection poolì„ ì´ìš©í•˜ì—¬ redsync ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±
	rs := redsync.New(pools...)

	mutexname := "my-global-mutex"

	// ì£¼ì–´ì§„ mutexnameì„ ì´ìš©í•˜ì—¬ Mutex ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±
	mutex := rs.NewMutex(mutexname)

	// Lockì„ íšë“í•˜ì—¬ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë‚˜ ìŠ¤ë ˆë“œê°€ Lockì„ íšë“í•  ìˆ˜ ì—†ë„ë¡ í•¨
	if err := mutex.Lock(); err != nil {
		panic(err)
	}

	// ì‘ì—… ìˆ˜í–‰
	{
		// do something
		time.Sleep(1 * time.Second)
	}

	// Lockì„ í•´ì œí•˜ì—¬ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ë‚˜ ìŠ¤ë ˆë“œê°€ Lockì„ íšë“í•  ìˆ˜ ìˆë„ë¡ í•¨
	if ok, err := mutex.Unlock(); !ok || err != nil {
		panic("unlock failed")
	}
}

```

ë§ˆì¹˜ í‰ë²”í•˜ê²Œ Lockì„ ì‚¬ìš©í•˜ë“¯ `NewMutex`ë¡œ ìƒì„±í•œ `mutex` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ `Lock`, `Unlock` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ Lockì„ íšë“í•˜ê±°ë‚˜ í’€ ìˆ˜ ìˆë‹¤.

### RedsyncëŠ” ì–´ë–»ê²Œ Redlock ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í• ê¹Œ?

ë¨¼ì € Mutex êµ¬ì¡°ì²´ë¥¼ ë³´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

```go
type Mutex struct {
	name   string
	expiry time.Duration

	tries     int
	delayFunc DelayFunc

	quorum int

	pools []redis.Pool
	
	// ...
}
```

ë‚´ë¶€ì ìœ¼ë¡œ lockContext ë©”ì„œë“œê°€ ì‹¤í–‰ë˜ëŠ”ë° ì•„ë˜ì™€ ê°™ì€ ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°€ì§€ê³  ìˆë‹¤.

```go
func (m *Mutex) lockContext(ctx context.Context, tries int) error
```

tries íšŸìˆ˜ ì´ë‚´ì—ì„œ ë½ íšë“ì„ ì‹œë„í•˜ë©°, ì‹¤íŒ¨í•˜ë©´ ì¬ì‹œë„í•œë‹¤. ì¬ì‹œë„ ë”œë ˆì´ëŠ” Redlock ì•Œê³ ë¦¬ì¦˜ ì›ì¹™ì— ë”°ë¼ì„œ randomí•˜ê²Œ ì§„í–‰í•œë‹¤.

```go
func(tries int) time.Duration {
			return time.Duration(rand.Intn(maxRetryDelayMilliSec-minRetryDelayMilliSec)+minRetryDelayMilliSec) * time.Millisecond
		},
```

ë‹¤ì‹œ `lockContext` ë©”ì„œë“œë¡œ ëŒì•„ê°€ ë³´ë©´,

```go
		n, err := func() (int, error) {
			// ...
			return m.actOnPoolsAsync(func(pool redis.Pool) (bool, error) {
				return m.acquire(ctx, pool, value)
			})
		}()
```

m.actOnPoolsAsyncë¼ëŠ” í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œë‹¤. ì´ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ë¥¼ ë°›ì•„ì„œ poolì„ ìˆœíšŒí•˜ë©° ì‹¤í–‰í•œë‹¤. ê·¸ë¦¬ê³  ë½ì— íšë“í•œ ë§ˆìŠ¤í„° ìˆ˜ì™€ ì—ëŸ¬ë¥¼ ë°˜í™˜í•œë‹¤.

```go
func (m *Mutex) actOnPoolsAsync(actFn func(redis.Pool) (bool, error)) (int, error) {
// ...
	for node, pool := range m.pools {
		go func(node int, pool redis.Pool) {
			r := result{node: node}
			r.statusOK, r.err = actFn(pool)
			ch <- r
		}(node, pool)
	}
// ...

// lock íšë“ì— ì„±ê³µí•œ ìˆ˜ë¥¼ countí•˜ì—¬ nì— ì €ì¥
	for range m.pools {
		r := <-ch
		if r.statusOK {
			n++
			// ...
			
		// n ë°˜í™˜
		return n, err
}
```

ê·¸ë¦¬ê³  lockContext í•¨ìˆ˜ì—ì„œëŠ” ì´ ê²°ê³¼ë¥¼ n, errë¡œ ë°›ê³  ìˆë‹¤. 

ë§ˆì§€ë§‰ìœ¼ë¡œ lockContext í•¨ìˆ˜ëŠ” ì•„ë˜ì²˜ëŸ¼ quorum ì´ìƒì˜ lock íšë“ì— ì„±ê³µí–ˆëŠ”ì§€, ì•„ì§ ë½ ìœ íš¨ì‹œê°„ì´ ë‚¨ì•˜ëŠ”ì§€ ê²€ì¦í•œë‹¤.

```go
if n >= m.quorum && now.Before(until) {
			m.value = value
			m.until = until
			return nil
		}
```

## Reference

[Distributed Locks with Redis](https://redis.io/docs/latest/develop/use/patterns/distributed-locks/)

[How to do distributed locking â€” Martin Kleppmannâ€™s blog](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)

[Is Redlock safe? - <antirez>](https://antirez.com/news/101)

[https://github.com/go-redsync/redsync](https://github.com/go-redsync/redsync)